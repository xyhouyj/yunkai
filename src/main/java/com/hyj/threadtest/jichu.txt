1、interrupted
    中断可以理解为线程的一个标志位，表示一个运行中的线程是否被其他线程进行了中断操作。
    其他线程可以调用该线程的interrupt()方法对其进行中断操作，但是如果该线程调用了wait
    或者sleep join 等方法时抛出InterruptedException异常，标志位将会被清除
    该线程可以调用 isInterrupted（）来感知其他线程对其自身的中断操作，不会清除中断标志位。
    可以调用Thread的静态方法 interrupted（）对当前线程进行中断操作，该方法会清除中断标志位
2、join方法
    join方法可以看做是线程间协作的一种方式。
    如果一个线程实例A执行了threadB.join(),其含义是：当前线程A会等待threadB线程终止后threadA才会继续执行。
3、sleep方法
    public static native void sleep(long millis)方法显然是Thread的静态方法，很显然它是让当前线程按照指定的时间休眠，其休眠时间的精度取决于处理器的计时器和调度器。
    需要注意的是如果当前线程获得了锁，sleep方法并不会失去锁。sleep方法经常拿来与Object.wait()方法进行比价，这也是面试经常被问的地方。
    两者主要的区别：
    sleep()方法是Thread的静态方法，而wait是Object实例方法
    wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方种使用。
    wait()方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；
    sleep()方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而wait()方法必须等待Object.notift/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。
4、yield
    public static native void yield();这是一个静态方法，一旦执行，它会是当前线程让出CPU，
    但是，需要注意的是，让出的CPU并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了CPU时间片当前线程依然会继续运行
    。另外，让出的时间片只会分配给当前线程相同优先级的线程。

    sleep()和yield()方法，同样都是当前线程会交出处理器资源，而它们不同的是:
        sleep()交出来的时间片其他线程都可以去竞争，也就是说都有机会获得当前线程让出的时间片。
        而yield()方法只允许与当前线程具有相同优先级的线程能够获得释放出来的CPU时间片。
5、守护线程：
    守护线程是一种特殊的线程，是系统的守护者，在后台默默地守护一些系统服务，比如垃圾回收线程，JIT线程就可以理解守护线程。
    与之对应的就是用户线程，用户线程就可以认为是系统的工作线程，它会完成整个系统的业务操作。
    当一个Java应用，只有守护线程的时候，虚拟机就会自然退出。
    守护线程在退出的时候并不会执行finnaly块中的代码，所以将释放资源等操作不要放在finnaly块中执行，这种操作是不安全的。