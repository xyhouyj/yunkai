(1) 为了使用ZooKeeper来实现分布式锁服务，我们使用顺序znode来为那些竞争锁的进程强制排序。

思路很简单：

① 首先指定一个作为锁的znode，通常用它来描述被锁定的实体，称为/leader；
② 然后希望获得锁的客户端创建一些短暂顺序znode，作为锁znode的子节点。
③ 在任何时间点，顺序号最小的客户端将持有锁。
    例如，有两个客户端差不多同时创建znode，分别为/leader/lock-1和/leader/lock-2，那么创建/leader/lock-1的客户端将会持有锁，因为它的znode顺序号最小。ZooKeeper服务是顺序的仲裁者，因为它负责分配顺序号。
④ 通过删除znode /leader/lock-l即可简单地将锁释放；
⑤ 另外，如果客户端进程死亡，对应的短暂znode也会被删除。
⑥ 接下来，创建/leader/lock-2的客户端将持有锁，因为它顺序号紧跟前一个。
⑦ 通过创建一个关于znode删除的观察，可以使客户端在获得锁时得到通知。

问题：
1、羊群效应
    第一个问题是这种实现会受到“羊群效应”(herd effect)的影响。
    考虑有成百上千客户端的情况，所有的客户端都在尝试获得锁，
    每个客户端都会在锁znode上设置一个观察，用于捕捉子节点的变化。
     每次锁被释放或另外一个进程开始申请获取锁的时候，观察都会被触发并且每个客户端都会收到一个通知。
     “羊群效应“就是指大量客户端收到同一事件的通知，但实际上只有很少一部分需要处理这一事件。
     在这种情况下，只有一个客户端会成功地获取锁，
     但是维护过程及向所有客户端发送观察事件会产生峰值流量，这会对ZooKeeper服务器造成压力。
     解决方案：
        优化通知的条件。------观察比自己小的节点的删除事件
        关键在于只有在前一个顺序号的子节点消失时才需要通知下一个客户端，
        而不是删除（或创建）任何子节点时都需要通知。
        在我们的例子中，如果客户端创建了znode /leader/lock-1、/leader/lock-2和／leader/lock-3，
        那么只有当/leader/lock-2消失时才需要通知／leader/lock-3对照的客户端；/leader/lock-1消失或有新的znode /leader/lock-4加入时，不需要通知该客户端。
   22、孤儿
    不能处理因连接丢失而导致的create操作失败。在这种情况下，我们不知道操作是成功还是失败。由于创建一个顺序znode是非幂等操作，所以我们不能简单地重试，因为如果第一次创建已经成功，
    重试会使我们多出一个永远删不掉的孤儿zriode(至少到客户端会话结束前）。不幸的结果是将会出现死锁。
        解决方法：
                。解决方案是在znode的名称中嵌入一个ID，如果客户端出现连接丢失的情况， 重新连接之后它便可以对锁节点的所有于节点进行检查，看看是否有子节点的名称中包含其ID。
                如果有一个子节点的名称包含其ID，它便知道创建操作已经成 功，不需要再创建子节点。如果没有子节点的名称中包含其ID，则客户端可以安全地创建一个新的顺序子节点。

 zzookeeper实现分布式锁的两种方案：
 1、利用节点名称的唯一性来实现共享锁
        ZooKeeper机制规定：同一个目录下只能有一个唯一的文件名。我们在Zookeeper目录/test目录下创建，两个客户端创建一个名为lock节点，只有一个能够成功。
        算法思路：利用名称唯一性，加锁操作时，只需要所有客户端一起创建/Leader/lock节点，只有一个创建成功，成功者获得锁。解锁时，只需删除/test/Lock节点，其余客户端再次进入竞争创建节点，直到所有客户端都获得锁。
 2、利用顺序节点实现共享锁
        ZooKeeper中还有一种名为临时节点的节点，临时节点由某个客户端创建，当客户端与ZooKeeper集群断开连接，。则该节点自动被删除。
        对于加锁操作，可以让所有客户端都去/lock目录下创建临时、顺序节点，如果创建的客户端发现自身创建节点序列号是/lock/目录下最小的节点，则获得锁。
        否则，监视比自己创建节点的序列号小的节点（当前序列在自己前面一个的节点），进入等待。解锁操作，只需要将自身创建的节点删除即可。具体算法流程如下图所示: